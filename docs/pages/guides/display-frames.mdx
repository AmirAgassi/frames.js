---
title: "Guide: Display Frames in your app"
description: "Frames.js is the react based framework for making frames. Debugger included."
---

# Quickstart Guide: Display Frames in your app (next.js + tailwind app router example)

1. Run `create-next-app`, and then  `yarn add @farcaster/core frames.js`

2. Create a file called `createFrameActionMessageWithSignerKey.ts`

```tsx filename="// ./app/createFrameActionMessageWithSignerKey.ts"
// ./app/createFrameActionMessageWithSignerKey.ts
import {
  CastId,
  NobleEd25519Signer,
  makeFrameAction,
  FarcasterNetwork,
  Message,
  FrameActionBody,
} from "@farcaster/core";

export async function createFrameActionMessageWithSignerKey(
  signerKey: string,
  {
    fid,
    url,
    buttonIndex,
    castId,
    inputText,
    state,
  }: {
    fid: number;
    url: Uint8Array;
    buttonIndex: number;
    inputText: Uint8Array | undefined;
    castId: CastId;
    state: Uint8Array | undefined;
  }
) {
  const signer = new NobleEd25519Signer(Buffer.from(signerKey.slice(2), "hex"));

  const messageDataOptions = {
    fid,
    network: FarcasterNetwork.MAINNET,
  };

  const message = await makeFrameAction(
    FrameActionBody.create({
      url,
      buttonIndex,
      castId,
      state,
      inputText: inputText !== undefined ? Buffer.from(inputText) : undefined,
    }),
    messageDataOptions,
    signer
  );

  if (message.isErr()) {
    console.error(message.error);
  }

  const trustedBytes = Buffer.from(
    Message.encode(message._unsafeUnwrap()).finish()
  ).toString("hex");

  return { message: message.unwrapOr(null), trustedBytes: trustedBytes };
}

```

3. Add proxies for routing frame requests via your backend for privacy + preventing CORS issues
```tsx filename="// ./app/frames/route.tsx"
// ./app/frames/route.tsx
export { GET, POST } from "frames.js/render/next";
```

4. Add the renderer to your page

```tsx filename="// ./app/page.tsx"
// ./app/page.tsx
"use client";
import {
  FrameUI,
  fallbackFrameContext,
  useFrame,
  FrameContext,
} from "frames.js/render";
import { FrameImageNext } from "frames.js/render/next";
import { FrameButton } from "frames.js";
import { createFrameActionMessageWithSignerKey } from "./createFrameActionMessageWithSignerKey";

export default function Page() {
  const farcasterUser = {
    fid: 1,
    privateKey: "0",
  };
  const signFrameAction = async ({
    buttonIndex,
    frameContext,
    frameButton,
    target,
    inputText,
    state,
    url,
  }: {
    target?: string;
    frameButton: FrameButton;
    buttonIndex: number;
    url: string;
    inputText?: string;
    state?: string;
    frameContext: FrameContext;
  }): Promise<{
    body: object;
    searchParams: URLSearchParams;
  }> => {
    if (!farcasterUser?.fid) {
      throw new Error("Missing data");
    }

    const { message, trustedBytes } =
      await createFrameActionMessageWithSignerKey(farcasterUser.privateKey, {
        fid: farcasterUser.fid,
        buttonIndex,
        castId: {
          fid: frameContext.castId.fid,
          hash: new Uint8Array(
            Buffer.from(frameContext.castId.hash.slice(2), "hex")
          ),
        },
        state: state !== undefined ? Buffer.from(state) : undefined,
        url: Buffer.from(url),
        // it seems the message in hubs actually requires a value here.
        inputText: inputText !== undefined ? Buffer.from(inputText) : undefined,
      });

    if (!message) {
      throw new Error("hub error");
    }

    const searchParams = new URLSearchParams({
      postType: frameButton?.action || "post",
      postUrl: target ?? "",
    });

    return {
      searchParams: searchParams,
      body: {
        untrustedData: {
          fid: farcasterUser.fid,
          url: url,
          messageHash: `0x${Buffer.from(message.hash).toString("hex")}`,
          timestamp: message.data.timestamp,
          network: 1,
          buttonIndex: Number(message.data.frameActionBody.buttonIndex),
          castId: {
            fid: frameContext.castId.fid,
            hash: frameContext.castId.hash,
          },
          inputText,
        },
        trustedData: {
          messageBytes: trustedBytes,
        },
      },
    };
  };
  const frameState = useFrame({
    homeframeUrl: "<INSERT HOME DOMAIN + ROUTE HERE>",
    // corresponds to the name of the route for POST in step 3
    frameActionRoute: "/frames",
    // corresponds to the name of the route for GET in step 3
    frameFetchRoute: "/frames",
    frameContext: fallbackFrameContext,
    // map to your identity if you have one
    authState: {
      user: {},
      isLoading: false,
      isLoggedIn: false,
      logout: () => null,
      promptLogin: () => null,
      signFrameAction: signFrameAction,
    },
  });

  return (
    <FrameUI frameState={frameState} theme={{}} FrameImage={FrameImageNext} />
  );
}

```

5. In order for the styles to work, your project should have tailwind set up as well as the tailwind.config.js rule

```tsx filename="// tailwind.config.js"
// tailwind.config.js
const config = {
    // ...
    content: [
        "./node_modules/frames.js/dist/render/next/*.{ts,tsx,js,css}",
        "./node_modules/frames.js/dist/render/*.{ts,tsx,js,css}",
        // ...
    ]
}
```

Done! 

If needed, you can implement `FrameUI` yourself, using the [FrameUI](https://github.com/framesjs/frames.js/blob/main/packages/frames.js/src/render/frame-ui.tsx) component as a template